"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdaptivePlaywrightCrawler = void 0;
const tslib_1 = require("tslib");
const timeout_1 = require("@apify/timeout");
const browser_1 = require("@crawlee/browser");
const core_1 = require("@crawlee/core");
const utils_1 = require("@crawlee/utils");
const cheerio_1 = require("cheerio");
const lodash_isequal_1 = tslib_1.__importDefault(require("lodash.isequal"));
const playwright_crawler_1 = require("./playwright-crawler");
const rendering_type_prediction_1 = require("./utils/rendering-type-prediction");
class AdaptivePlaywrightCrawlerStatistics extends core_1.Statistics {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }); // this needs to be assigned for a valid override, but the initialization is done by a reset() call from the parent constructor
    }
    reset() {
        super.reset();
        this.state.httpOnlyRequestHandlerRuns = 0;
        this.state.browserRequestHandlerRuns = 0;
        this.state.renderingTypeMispredictions = 0;
    }
    async _maybeLoadStatistics() {
        await super._maybeLoadStatistics();
        const savedState = await this.keyValueStore?.getValue(this.persistStateKey);
        if (!savedState) {
            return;
        }
        this.state.httpOnlyRequestHandlerRuns = savedState.httpOnlyRequestHandlerRuns;
        this.state.browserRequestHandlerRuns = savedState.browserRequestHandlerRuns;
        this.state.renderingTypeMispredictions = savedState.renderingTypeMispredictions;
    }
    trackHttpOnlyRequestHandlerRun() {
        var _a;
        (_a = this.state).httpOnlyRequestHandlerRuns ?? (_a.httpOnlyRequestHandlerRuns = 0);
        this.state.httpOnlyRequestHandlerRuns += 1;
    }
    trackBrowserRequestHandlerRun() {
        var _a;
        (_a = this.state).browserRequestHandlerRuns ?? (_a.browserRequestHandlerRuns = 0);
        this.state.browserRequestHandlerRuns += 1;
    }
    trackRenderingTypeMisprediction() {
        var _a;
        (_a = this.state).renderingTypeMispredictions ?? (_a.renderingTypeMispredictions = 0);
        this.state.renderingTypeMispredictions += 1;
    }
}
/**
 * An extension of {@apilink PlaywrightCrawler} that uses a more limited request handler interface so that it is able to switch to HTTP-only crawling when it detects it may be possible.
 *
 * **Example usage:**
 *
 * ```javascript
 * const crawler = new AdaptivePlaywrightCrawler({
 *     renderingTypeDetectionRatio: 0.1,
 *     async requestHandler({ querySelector, pushData, enqueueLinks, request, log }) {
 *         // This function is called to extract data from a single web page
 *         const $prices = await querySelector('span.price')
 *
 *         await pushData({
 *             url: request.url,
 *             price: $prices.filter(':contains("$")').first().text(),
 *         })
 *
 *         await enqueueLinks({ selector: '.pagination a' })
 *     },
 * });
 *
 * await crawler.run([
 *     'http://www.example.com/page-1',
 *     'http://www.example.com/page-2',
 * ]);
 * ```
 *
 * @experimental
 */
class AdaptivePlaywrightCrawler extends playwright_crawler_1.PlaywrightCrawler {
    constructor({ requestHandler, renderingTypeDetectionRatio, renderingTypePredictor, resultChecker, resultComparator, statisticsOptions, ...options }, config = core_1.Configuration.getGlobalConfig()) {
        super(options, config);
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: config
        });
        Object.defineProperty(this, "adaptiveRequestHandler", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "renderingTypePredictor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resultChecker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resultComparator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "stats", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.adaptiveRequestHandler = requestHandler;
        this.renderingTypePredictor = renderingTypePredictor ?? new rendering_type_prediction_1.RenderingTypePredictor({ detectionRatio: renderingTypeDetectionRatio });
        this.resultChecker = resultChecker ?? (() => true);
        if (resultComparator !== undefined) {
            this.resultComparator = resultComparator;
        }
        else if (resultChecker !== undefined) {
            this.resultComparator = (resultA, resultB) => this.resultChecker(resultA) && this.resultChecker(resultB);
        }
        else {
            this.resultComparator = (resultA, resultB) => {
                return resultA.datasetItems.length === resultB.datasetItems.length
                    && resultA.datasetItems.every((itemA, i) => {
                        const itemB = resultB.datasetItems[i];
                        return (0, lodash_isequal_1.default)(itemA, itemB);
                    });
            };
        }
        this.stats = new AdaptivePlaywrightCrawlerStatistics({
            logMessage: `${this.log.getOptions().prefix} request statistics:`,
            config,
            ...statisticsOptions,
        });
    }
    async _runRequestHandler(crawlingContext) {
        const url = new URL(crawlingContext.request.loadedUrl ?? crawlingContext.request.url);
        const renderingTypePrediction = this.renderingTypePredictor.predict(url, crawlingContext.request.label);
        const shouldDetectRenderingType = Math.random() < renderingTypePrediction.detectionProbabilityRecommendation;
        if (!shouldDetectRenderingType) {
            crawlingContext.log.info(`Predicted rendering type ${renderingTypePrediction.renderingType} for ${crawlingContext.request.url}`);
        }
        if (renderingTypePrediction.renderingType === 'static' && !shouldDetectRenderingType) {
            crawlingContext.log.info(`Running HTTP-only request handler for ${crawlingContext.request.url}`);
            this.stats.trackHttpOnlyRequestHandlerRun();
            const plainHTTPRun = await this.runRequestHandlerWithPlainHTTP(crawlingContext);
            if (plainHTTPRun.ok && this.resultChecker(plainHTTPRun.result)) {
                crawlingContext.log.info(`HTTP-only request handler succeeded for ${crawlingContext.request.url}`);
                await this.commitResult(crawlingContext, plainHTTPRun.result);
                return;
            }
            if (!plainHTTPRun.ok) {
                crawlingContext.log.exception(plainHTTPRun.error, `HTTP-only request handler failed for ${crawlingContext.request.url}`);
            }
            else {
                crawlingContext.log.warning(`HTTP-only request handler returned a suspicious result for ${crawlingContext.request.url}`);
                this.stats.trackRenderingTypeMisprediction();
            }
        }
        crawlingContext.log.info(`Running browser request handler for ${crawlingContext.request.url}`);
        this.stats.trackBrowserRequestHandlerRun();
        const browserRun = await this.runRequestHandlerInBrowser(crawlingContext);
        if (!browserRun.ok) {
            throw browserRun.error;
        }
        await this.commitResult(crawlingContext, browserRun.result);
        if (shouldDetectRenderingType) {
            crawlingContext.log.info(`Detecting rendering type for ${crawlingContext.request.url}`);
            const plainHTTPRun = await this.runRequestHandlerWithPlainHTTP(crawlingContext);
            const detectionResult = (() => {
                if (!plainHTTPRun.ok) {
                    return 'clientOnly';
                }
                if (this.resultComparator(plainHTTPRun.result, browserRun.result)) {
                    return 'static';
                }
                return 'clientOnly';
            })();
            crawlingContext.log.info(`Detected rendering type ${detectionResult} for ${crawlingContext.request.url}`);
            this.renderingTypePredictor.storeResult(url, crawlingContext.request.label, detectionResult);
        }
    }
    async commitResult(crawlingContext, { calls, keyValueStoreChanges }) {
        await Promise.all([
            ...calls.pushData.map(async (params) => crawlingContext.pushData(...params)),
            ...calls.enqueueLinks.map(async (params) => await crawlingContext.enqueueLinks(...params)),
            ...calls.addRequests.map(async (params) => crawlingContext.addRequests(...params)),
            ...Object.entries(keyValueStoreChanges).map(async ([storeIdOrName, changes]) => {
                const store = await crawlingContext.getKeyValueStore(storeIdOrName);
                await Promise.all(Object.entries(changes).map(async ([key, { changedValue, options }]) => store.setValue(key, changedValue, options)));
            }),
        ]);
    }
    async runRequestHandlerInBrowser(crawlingContext) {
        const result = new core_1.RequestHandlerResult(this.config, AdaptivePlaywrightCrawler.CRAWLEE_STATE_KEY);
        try {
            await super._runRequestHandler.call(new Proxy(this, {
                get: (target, propertyName, receiver) => {
                    if (propertyName === 'userProvidedRequestHandler') {
                        return (playwrightContext) => this.adaptiveRequestHandler({
                            request: crawlingContext.request,
                            log: crawlingContext.log,
                            querySelector: async (selector, timeoutMs) => {
                                const locator = playwrightContext.page.locator(selector).first();
                                await locator.waitFor({ timeout: timeoutMs });
                                return (await playwrightContext.parseWithCheerio())(selector);
                            },
                            enqueueLinks: async (options = {}) => {
                                const selector = options.selector ?? 'a';
                                const locator = playwrightContext.page.locator(selector).first();
                                await locator.waitFor();
                                const urls = await (0, browser_1.extractUrlsFromPage)(playwrightContext.page, selector, options.baseUrl ?? playwrightContext.request.loadedUrl ?? playwrightContext.request.url);
                                await result.enqueueLinks({ ...options, urls });
                            },
                            addRequests: result.addRequests,
                            pushData: result.pushData,
                            useState: result.useState,
                            getKeyValueStore: result.getKeyValueStore,
                        });
                    }
                    return Reflect.get(target, propertyName, receiver);
                },
            }), crawlingContext);
            return { result, ok: true };
        }
        catch (error) {
            return { error, ok: false };
        }
    }
    async runRequestHandlerWithPlainHTTP(crawlingContext) {
        const result = new core_1.RequestHandlerResult(this.config, AdaptivePlaywrightCrawler.CRAWLEE_STATE_KEY);
        const response = await crawlingContext.sendRequest({});
        const loadedUrl = response.url;
        crawlingContext.request.loadedUrl = loadedUrl;
        const $ = (0, cheerio_1.load)(response.body);
        try {
            await (0, timeout_1.addTimeoutToPromise)(async () => this.adaptiveRequestHandler({
                request: crawlingContext.request,
                log: crawlingContext.log,
                querySelector: (selector) => $(selector),
                enqueueLinks: async (options = {}) => {
                    const urls = (0, utils_1.extractUrlsFromCheerio)($, options.selector, options.baseUrl ?? loadedUrl);
                    await result.enqueueLinks({ ...options, urls });
                },
                addRequests: result.addRequests,
                pushData: result.pushData,
                useState: result.useState,
                getKeyValueStore: result.getKeyValueStore,
            }), this.requestHandlerTimeoutInnerMillis, 'Request handler timed out');
            return { result, ok: true };
        }
        catch (error) {
            return { error, ok: false };
        }
    }
}
exports.AdaptivePlaywrightCrawler = AdaptivePlaywrightCrawler;
//# sourceMappingURL=adaptive-playwright-crawler.js.map